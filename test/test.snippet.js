const isBrowser = typeof window !== 'undefined';
const isNode = !isBrowser;

let assert, readFileSync, JSDOM, VirtualConsole;

if (isNode) {
  ({ assert } = await import('chai'));
  ({ readFileSync } = await import('fs'));
  ({ JSDOM, VirtualConsole } = await import('jsdom'));
} else {
  assert = chai.assert;
}

function init() {
  if (isNode) {
    const virtualConsole = new VirtualConsole();

    const dom = new JSDOM(`<script>${readFileSync('./src/snippet.js').toString()}</script>`, {
      runScripts: 'dangerously',
      virtualConsole,
    });
    virtualConsole.sendTo(console);

    return dom.window;
  }
  return window;
}

async function $oReset() {
  if (!isBrowser) return;

  let snippet;
  if ((snippet = document.getElementById('snippet'))) {
    snippet.remove();
  }
  if (window.$o) {
    delete window.$o;
  }

  const head = document.getElementsByTagName('head')[0];
  snippet = document.createElement('script');
  snippet.src = `../src/snippet.js?cache-bust=${Math.floor(Math.random() * 100000).toString(16)}`;
  snippet.setAttribute('id', 'snippet');
  head.appendChild(snippet);

  await new Promise((resolve) => {
    snippet.onload = resolve;
  });

  window.$o.seed = parseSeed('6fe6fb92b8b141fab578f4a3bd43b347');
  window.$o.rnd(null);
}
function parseSeed(hex) {
  const bytes = [],
    abcd = new Uint32Array(4);
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.substr(i, 2), 16));
  }
  for (let i = 0; i < 4; i++) {
    abcd[i] = (bytes[i * 4] << 24) | (bytes[i * 4 + 1] << 16) | (bytes[i * 4 + 2] << 8) | bytes[i * 4 + 3];
  }
  return abcd;
}
describe('$o', () => {
  beforeEach('reset + seed $o', $oReset);
  [
    ['seed', 'rnd'],
    ['seedGlobal', 'rndGlobal'],
  ].forEach(([seed, rnd]) => {
    describe(`#${rnd}()`, () => {
      it('should be deterministic', () => {
        const { $o } = init();
        $o[seed] = parseSeed('6fe6fb92b8b141fab578f4a3bd43b347');
        $o[rnd](null);

        const result = [$o[rnd](), $o[rnd](), $o[rnd](), $o[rnd]()];
        const expected = [0.8415740944910794, 0.42034225002862513, 0.5494970194995403, 0.8108424984384328];
        assert.deepEqual(result, expected);
      });

      it('can be reset by passing null', () => {
        const { $o } = init();
        $o[seed] = parseSeed('6fe6fb92b8b141fab578f4a3bd43b347');
        for (let i = 0; i < 2; i++) {
          $o[rnd](null);
          const result = [$o[rnd](), $o[rnd](), $o[rnd](), $o[rnd]()];
          const expected = [0.8415740944910794, 0.42034225002862513, 0.5494970194995403, 0.8108424984384328];
          assert.deepEqual(result, expected);
        }
      });
    });
  });

  it('sfc32 is good enough compared to Math.random()', function () {
    this.timeout(15000);

    const { $o } = init();
    const N = 1000;
    const M = 1e6;
    const sfc = () => Math.floor($o.rnd() * N);
    const math = () => Math.floor(Math.random() * N);
    const [[valuesSfc32, lowestFreqSfc32, highestFreqSfc32], [valuesMath, lowestFreqMath, highestFreqMath]] =
      [sfc, math].map((fn) => {
        const output = [];
        for (let i = 0; i < M; i++) {
          output.push(fn());
        }

        const stats = output.reduce((acc, n) => {
          if (!acc.hasOwnProperty(n)) {
            acc[n] = 0;
          }
          acc[n]++;
          return acc;
        }, {});
        const s2 = Object.entries(stats).map(([k, v]) => v / (M / N));
        s2.sort((a, b) => a - b);
        const [values, lowestFreq, highestFreq] = [s2.length, s2[0], s2[s2.length - 1]];
        return [values, lowestFreq, highestFreq];
      });
    // both generated all nats from 0 to N
    assert(valuesSfc32 == valuesMath);
    // least/most frequently generated by both have similar frequencies
    assert(Math.abs(lowestFreqSfc32 - lowestFreqMath) < 0.05);
    assert(Math.abs(highestFreqSfc32 - highestFreqMath) < 0.05);
  });

  describe('#registerExport()', () => {
    beforeEach('reset + seed $o', $oReset);
    const exportPng = async ({ resolution: { x, y } }) => 'foo';

    it('should register a default export', () => {
      const { $o } = init();
      $o.registerExport({ resolution: { x: 1024, y: 1024 }, default: true, mime: 'image/png' }, exportPng);
      assert.equal($o._exports['image/png'].resolution.x, 1024);
      assert.equal($o._exports['image/png'].default, true);
    });

    it('default export gets called', async function () {
      const { $o, window } = init();
      const exportPng = async ({ resolution: { x, y } }) => {
        assert.equal(x, 900);
        assert.equal(y, 900);
        return 'foo';
      };
      $o.registerExport({ resolution: { x: 1024, y: 1024 }, default: true, mime: 'image/png' }, exportPng);
      await new Promise((resolve) => setTimeout(resolve()), 100);
      window.postMessage({ id: '$o:export', mime: 'image/png', resolution: { x: 900, y: 900 } }, '*');

      return new Promise((resolve) => {
        const wait = ({ data }) => {
          if (data.id === '$o:exported') {
            assert.equal(data.exported, 'foo');
            window.removeEventListener('message', wait);
            resolve();
          }
        };
        window.addEventListener('message', wait);
      });
    });

    it('default export is used for capture at registered resolution', async function () {
      const { $o, window } = init();
      $o.isCapture = true;
      const exportPng = async ({ resolution: { x, y } }) => {
        assert.equal(x, 1024);
        assert.equal(y, 1024);
        return 'foo';
      };
      $o.registerExport({ resolution: { x: 1024, y: 1024 }, default: true, mime: 'image/png' }, exportPng);
      await new Promise((resolve) => setTimeout(resolve()), 100);

      await window.capture();

      return new Promise((resolve) => {
        const wait = ({ data }) => {
          if (data.id === '$o:captured') {
            assert.equal(data.exported, 'foo');
            assert.deepEqual(data, {
              mime: 'image/png',
              resolution: { x: 1024, y: 1024 },
              aspectRatio: undefined,
              exported: 'foo',
              id: '$o:captured',
            });
            window.removeEventListener('message', wait);
            resolve();
          }
        };
        window.addEventListener('message', wait);
      });
    });
  });
});
